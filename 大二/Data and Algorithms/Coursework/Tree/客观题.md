# 简答题

## 树

### Q：如下表7.3所列的数据表给出了在一篇有19710个词的英文文章中最普通的15个单词的出现频度。假定一篇正文仅由上述字符数据表中的词组成，那么它们的最佳编码是什么?平均长度是多少?

![http://202.204.62.165/cguserImages?_img=2658cb671fad315e6007200f0b99933f.png](http://202.204.62.165/cguserImages?_img=2658cb671fad315e6007200f0b99933f.png)

- 最佳编码是霍夫曼编码
- 平均长度计算

![](/home/andy/USTB-Course/大二/Data and Algorithms/Coursework/Tree/客观题.assets/简答题1.jpg)

| 单词 | 出现评率 |  编码  | 码长 |
| :--: | :------: | :----: | :--: |
|  is  |   190    | 00000  |  5   |
|  he  |   195    | 00001  |  5   |
|  in  |   450    |  0001  |  4   |
|  a   |   541    |  001   |  3   |
| that |   242    | 01000  |  5   |
|  be  |   123    | 010010 |  6   |
| are  |   124    | 010011 |  6   |
| and  |   462    |  0101  |  4   |
|  of  |   677    |  011   |  3   |
| His  |   138    | 10000  |  5   |
| for  |   157    | 10001  |  5   |
|  on  |   174    | 10010  |  5   |
|  at  |   181    | 10011  |  5   |
|  to  |   518    |  101   |  3   |
| The  |   1192   |   11   |  2   |

计算得 平均码长为 3.562

### Q：假设二叉树采用二叉链存储结构存储，设计一个算法求其中最小值的节点值。

采用递归遍历的方法，比较所有节点的值

#### 算法步骤
1. **处理空树情况**：如果二叉树为空，返回 INT_MAX，确保不影响最小值比较
2. **初始化最小值**：以当前节点的值作为初始最小值
3. **递归遍历左子树**：获取左子树中的最小值，并与当前最小值比较，更新最小值
4. **递归遍历右子树**：获取右子树中的最小值，并与当前最小值比较，更新最小值
5. **返回最小值**：经过左右子树的比较后，返回当前最小值

#### 代码实现
```cpp
// 二叉树节点结构体
struct TreeNode {
    int data;
    TreeNode* left;
    TreeNode* right;
    
    TreeNode(int val) : data(val), left(nullptr), right(nullptr) {}
};

// 递归寻找最小值函数
int findMinValue(TreeNode* root) {
    if (root == nullptr) {
        return INT_MAX;  // 空节点返回最大整数值
    }
    
    int current_val = root->data;
    int left_min = findMinValue(root->left);
    int right_min = findMinValue(root->right);
    
    return min(current_val, min(left_min, right_min));
}
```

#### 算法分析

- **时间复杂度** ：`O(n)` 遍历所有节点一次
- **空间复杂度** ：`O(h)` 递归深度等于树的高度 h

### Q：假设二叉树采用二叉链存储结构存储，设计一个算法，求先序遍历序列中第k(1≤k≤二叉树中节点个数)个节点的值。

利用栈来模拟先序遍历的过程，并在遍历过程中计数，直到访问到第k个节点

#### 算法步骤
1. **初始化栈**：将根节点压入栈中
2. **初始化计数器**：`count` 置 0，用于记录已访问的节点数目
3. **遍历栈**：
   1. 弹出栈顶节点`node`
   2. 将`count`增1，若`count`等于k，则返回`node`的值
   3. 若`node`的右子节点存在，将其压入栈中
   4. 若`node`的左子节点存在，将其压入栈中

4. 重复步骤3 直到栈为空或找到第k个节

#### 代码实现
```cpp
int findKthPreorder(TreeNode* root, int k) {
    if (root == nullptr) return -1; 
    std::stack<TreeNode*> s;
    s.push(root);
    int count = 0;
    while (!s.empty()) {
        TreeNode* node = s.top();
        s.pop();
        count++;
        if (count == k) {
            return node->val; // 找到目标节点
        }
        if (node->right) s.push(node->right);
        if (node->left) s.push(node->left);
    }
}
```

#### 算法分析
- **时间复杂度**：`O(n)` 每个节点最多被压入和弹出栈各一次
- **空间复杂度**：`O(h)` h为二叉树的高度 

### Q：请以二叉链存储结构为例介绍二叉树查找节点FindNode(*b,x)算法的实现

使用栈模拟递归过程，遍历二叉树，找到值为 x 的节点

#### 算法步骤
1. **初始化栈**：将根节点压入栈中
2. **遍历栈**：
   1. 取出栈顶节点 `node`，检查它是否是目标节点，如果是则返回节点`node`
   2. 若`node`的右子节点存在，将其压入栈中
   3. 若`node`的左子节点存在，将其压入栈中

3. 重复步骤3 直到栈为空或找到值为 x 的节点

#### 代码实现
```c
TreeNode* FindNodeNonRecursive(TreeNode* root, int x) {
    if (root == nullptr) return nullptr;

    std::stack<TreeNode*> s;
    s.push(root); // 根节点入栈

    while (!s.empty()) {
        TreeNode* node = s.top();
        s.pop();
        if (node->data == x) {
            return node; // 找到目标节点
        }
        // 右子树先入栈，保证左子树先被处理
        if (node->right) s.push(node->right);
        if (node->left) s.push(node->left);
    }
    return nullptr; // 未找到
}
```

#### 算法分析
- **时间复杂度**：最坏情况下遍历所有节点，时间复杂度为 `O(n)`
- **空间复杂度**：递归深度取决于树的高度，平均为 `O(log n)`
- **遍历顺序**：采用先序遍历（根→左→右），返回第一个匹配的节点

### Q：已知一棵完全二叉树共有892个节点，试求:

(1)树的层数。

(2)单支节点数。

(3)叶子节点数。

(4)最小的叶子节点的编号。

#### 1. 树的层数为 10
- 前  k-1  层为满二叉树，节点数为  2^{k-1} - 1
- 第  k  层节点数  m  满足  1 <= m <=  2^{k-1}
- 总节点数 n = 2^{k-1} - 1 + m

代入  n = 892 
- 当  k = 10  时，前9层节点数为 2^9 - 1 = 511
- 第10层节点数  m = 892 - 511 = 381
- 满足  1 <= 381 <= 512

#### 2. 单支节点数为 1
- 第9层有  2^8 = 256 个节点
- 第10层有 381 个节点，需父节点数为 191 个
- 前190个父节点各有两个子节点，最后一个父节点仅有一个左子节点

#### 3. 叶子节点数为 446
- 第10层有 381 个叶子节点
- 第9层未被使用的节点数 256 - 191 = 65 
- 总叶子节点数为 381 + 65 = 446

#### 4. 最小的叶子节点的编号为 447
- 第9层节点编号范围为256~511，其中未被使用的节点编号为447~511

### Q：已知一棵完全二叉树的第6层(设根节点为第1层)有8个叶子节点，则该完全二叉树的节点个数最多是多少?最少是多少?

- 情况1：树高为6层

  - 此时第6层的所有节点均为叶子节点，且有 8 个叶子节点
  - 总节点数为前5层的满二叉树节点数 2^5 - 1 = 31 加上第6层的8个节点，共  31 + 8 = 39 

- 情况2：树高为7层

  - 第6层的叶子节点为 8 个，其余节点为非叶子节点 

  - 设第6层有  y 个非叶子节点，则第7层有 2y 个节点

  - 总节点数为 31 + (y + 8) + 2y = 39 + 3y

    - 最小值：当  y = 1  时，第7层有2个节点，总节点数为  39 + 3 * 1 = 42   

    - 最大值：当  y = 24  时，第7层有48个节点，总节点数为 39 +  3 * 24 = 111 

- 最少节点数为情况1的 39
- 最多节点数为情况2的 111

### Q：有n个叶子节点的3次树的最少层数是多少?

- 第  k  层最多有  3^{k-1}  个叶子节点  
- 当叶子数  n  满足  3^{h-2} < n < 3^{h-1}  时，最少需要  h  层
- 通过解不等式  3^{h-1} >= n ，得  h =  Ceiling( log_3(n) )+ 1

最少层数是 Ceiling( log_3(n) )+ 1

### Q：已知一棵度为4的树中，度为i(i>1)的节点个数有i个，问该树中有多少个叶子节点?

设度为1的节点个数为 X ，叶子节点的个数为 N

总度数为 1 * X + 2 * 2 + 3 * 3 + 4 * 4 = X + 29

总节点数为 N + X + 2 + 3 + 4 = X + 29 +1

- 叶子节点的个数是 21

### Q：若一棵度为4的树中度为1、2、3、4的节点个数分别为4、3、2、2，则该树叶子节点的个数是多少?总节点个数是多少?

设叶子节点的个数为 X 

总度数为 1 * 4 + 2 * 3 + 3 * 2 + 4 * 2 = 24

总节点数为 4 + 3 + 2 + 2 + X = 24 + 1

- 叶子节点的个数是 14
- 总节点个数是 25

### Q：有一棵树的括号表示为 A(B,C(E,F(G)),D)，回答下面的问题:

(1)这棵树的根节点是多少?

(2)这棵树的叶子节点是什么?

(3)节点C的度是多少?

(4)这棵树的度为多少?

(5)这棵树的层数是多少?

(6)节点C的孩子节点是哪些?

(7)节点C的双亲节点是谁?

1. 根节点是 A
2. 叶子节点是 B E G D
3. 节点C的度是 2
4. 这棵树的度为 3
5. 这棵树的层数是 4
6. 节点C的孩子节点是 E F
7. 节点C的双亲节点是 A