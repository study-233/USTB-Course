# 循环队列

## 循环队列的定义

**循环队列**是一种线性数据结构，遵循**先进先出（FIFO）**原则，但将存储空间的**逻辑首尾相连**，形成一个环形结构。它的核心思想是：
- 当队尾指针（`rear`）到达数组末尾时，可以绕到数组开头继续使用空间。
- 通过牺牲一个存储单元，解决普通队列的“假溢出”问题（队列未满但无法插入新元素）。

---

## 循环队列的实现逻辑
假设用数组 `qu[0..M]` 实现循环队列：
- **队首指针** `front`：指向队首元素的**前一个位置**（初始为 `0`）。
- **队尾指针** `rear`：指向队尾元素的**当前位置**（初始为 `0`）。
- **队满条件**：`(rear + 1) % (M+1) == front`。
- **队空条件**：`front == rear`。

#### **关键点**
1. **牺牲一个空间**：队列实际最多能存储 `M` 个元素（而非 `M+1`），以区分队空和队满。
2. **模运算**：通过 `(指针 ± 1) % (M+1)` 实现指针的循环移动。

---

## 循环队列的基本操作
以下用代码伪码说明核心操作：

#### **1. 判断队空**
```python
def is_empty(front, rear):
    return front == rear
```

#### **2. 判断队满**
```python
def is_full(front, rear, M):
    return (rear + 1) % (M + 1) == front
```

#### **3. 入队操作**
```python
def enqueue(qu, front, rear, M, value):
    if is_full(front, rear, M):
        raise Exception("队列已满")
    rear = (rear + 1) % (M + 1)  # rear 指向新位置
    qu[rear] = value
    return rear  # 返回新的 rear
```

#### **4. 出队操作**
```python
def dequeue(qu, front, rear, M):
    if is_empty(front, rear):
        raise Exception("队列为空")
    front = (front + 1) % (M + 1)  # front 指向新位置
    value = qu[front]
    return value, front  # 返回出队元素和新的 front
```

---

## 常见问题解析
#### **1. 为什么队满条件是 `(rear + 1) % (M+1) == front`？**
- 当队列满时，`rear` 的下一个位置是 `front`，但为了与队空（`front == rear`）区分，需要牺牲一个空间。例如，若数组长度为 `M+1`，则实际最多存储 `M` 个元素。

#### **2. 为什么队列最大容量是 `M` 而不是 `M+1`？**
- 因为队满时，`rear` 和 `front` 之间必须间隔一个空位。例如，当 `M+1 = 5` 时，队列最多存储 `4` 个元素。

#### **3. 循环队列 vs 普通队列**
| 特性       | 普通队列           | 循环队列             |
| ---------- | ------------------ | -------------------- |
| 空间利用率 | 低（假溢出问题）   | 高（循环利用空间）   |
| 实现复杂度 | 简单               | 需要处理模运算       |
| 适用场景   | 临时存储、简单场景 | 操作系统、缓冲区管理 |

---

## 实例分析
假设 `M = 3`（数组长度为 `4`），初始状态 `front = rear = 0`：
1. **入队元素 `A`**：
   - `rear = (0+1) % 4 = 1`，`qu[1] = A`。
   - 状态：`front=0`, `rear=1`。
2. **入队元素 `B`**：
   - `rear = (1+1) % 4 = 2`，`qu[2] = B`。
3. **出队**：
   - `front = (0+1) % 4 = 1`，返回 `A`。
   - 状态：`front=1`, `rear=2`。
4. **入队元素 `C`**：
   - `rear = (2+1) % 4 = 3`，`qu[3] = C`。
5. **入队元素 `D`**：
   - `rear = (3+1) % 4 = 0`，`qu[0] = D`。
   - 此时队满：`(0+1) % 4 = 1 == front=1`，无法继续入队。

---

## 总结
- **核心公式**：
  - 队空：`front == rear`
  - 队满：`(rear + 1) % (M+1) == front`
- **关键技巧**：通过模运算实现指针的循环移动，牺牲一个空间避免队空队满冲突。

如果还有疑问或需要进一步解释，请随时告诉我！ 😊